{"version":3,"sources":["components/Node.jsx","algorithm/dijkstra.js","components/PathFinderVisualizer.jsx","App.js","index.js"],"names":["Node","this","props","row","col","isStart","isFinish","isVisited","isWall","isPath","onMouseDown","onMouseEnter","onMouseUp","className","id","Component","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","node","grid","unvisitedNeighbors","neighbors","push","length","filter","neighbor","getUnvisitedNeighbors","previousNode","getAllNodes","nodes","START_NODE_ROW","Math","floor","random","START_NODE_COL","END_NODE_ROW","END_NODE_COL","MAX_COL","PathFinderVisualizer","generateGrid","currentRow","createNode","document","getElementById","Infinity","animate","visitedNodesInOrder","i","setTimeout","drawShortestPath","state","path","finishNode","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","visualizeDijkstra","startNode","closestNode","shift","map","dijkstra","handleMouseDown","newGrid","getNewGridWithWalls","setState","isMousePressed","handleMouseEnter","handleMouseUp","slice","reset","onClick","rowIdx","key","nodeIdx","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.e5f70773.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"../css/Node.css\";\r\n\r\nclass Node extends Component {\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isFinish,\r\n      isVisited,\r\n      isWall,\r\n      isPath,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n    } = this.props;\r\n    let className = \"node\";\r\n    if (isStart) className = \"node node-start\";\r\n    else if (isFinish) className = \"node node-end\";\r\n    else if (isVisited) className = \"node node-visited\";\r\n    else if (isWall) className = \"node node-wall\";\r\n    if (isPath && !isStart && !isFinish) className = \"node node-path\";\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={className}\r\n        onMouseDown={onMouseDown}\r\n        onMouseEnter={onMouseEnter}\r\n        onMouseUp={onMouseUp}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Node;\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) {\r\n      for (const node in getAllNodes) {\r\n        node.isVisited = false;\r\n      }\r\n      return visitedNodesInOrder;\r\n    }\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) {\r\n      visitedNodesInOrder.map((node) => (node.isVisited = false));\r\n      return visitedNodesInOrder;\r\n    }\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node\";\r\nimport \"../css/PathVisualizer.css\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithm/dijkstra\";\r\n\r\nconst MAX_ROW = 20;\r\nconst MAX_COL = 50;\r\nconst START_NODE_ROW = Math.floor(Math.random() * MAX_ROW);\r\nconst START_NODE_COL = Math.floor((Math.random() * MAX_COL) / 2);\r\nconst END_NODE_ROW = Math.floor(Math.random() * MAX_ROW);\r\nconst END_NODE_COL = Math.floor((Math.random() * MAX_COL) / 2 + MAX_COL / 2);\r\nconst TIMEOUT = 5;\r\n\r\nclass PathFinderVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n\r\n    this.state = {\r\n      grid: [],\r\n      isMousePressed: false,\r\n    };\r\n  }\r\n\r\n  generateGrid = () => {\r\n    const nodes = [];\r\n\r\n    for (let row = 0; row < MAX_ROW; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < MAX_COL; col++) {\r\n        let node = this.createNode(row, col);\r\n        if (\r\n          node.isStart &&\r\n          document.getElementById(`node-${node.row}-${node.col}`)\r\n        )\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-start\";\r\n        else if (\r\n          node.isFinish &&\r\n          document.getElementById(`node-${node.row}-${node.col}`)\r\n        )\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-end\";\r\n        else if (document.getElementById(`node-${node.row}-${node.col}`))\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node\";\r\n        currentRow.push(node);\r\n      }\r\n      nodes.push(currentRow);\r\n    }\r\n\r\n    return nodes;\r\n  };\r\n\r\n  createNode = (row, col) => {\r\n    let currentNode = {\r\n      row,\r\n      col,\r\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n      isFinish: row === END_NODE_ROW && col === END_NODE_COL,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      isPath: false,\r\n    };\r\n    return currentNode;\r\n  };\r\n\r\n  componentDidMount() {\r\n    const grid = this.generateGrid();\r\n    this.setState({\r\n      grid,\r\n    });\r\n  }\r\n\r\n  animate = (visitedNodesInOrder) => {\r\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        if (!node.isStart && !node.isFinish)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n      }, TIMEOUT * i);\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.drawShortestPath(this.state.grid[END_NODE_ROW][END_NODE_COL]);\r\n        }, TIMEOUT * i);\r\n      }\r\n    }\r\n  };\r\n\r\n  drawShortestPath = (node) => {\r\n    const path = getNodesInShortestPathOrder(node);\r\n    for (let i = 0; i < path.length; i++) {\r\n      setTimeout(() => {\r\n        const node = path[i];\r\n        if (!node.isStart && !node.isFinish)\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-path\";\r\n      }, TIMEOUT * i);\r\n    }\r\n  };\r\n\r\n  visualizeDijkstra = () => {\r\n    const grid = this.state.grid;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const endNode = grid[END_NODE_ROW][END_NODE_COL];\r\n\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, endNode);\r\n    this.animate(visitedNodesInOrder);\r\n  };\r\n\r\n  handleMouseDown = (row, col) => {\r\n    if (\r\n      !(\r\n        (row === START_NODE_ROW && col === START_NODE_COL) ||\r\n        (row === END_NODE_ROW && col === END_NODE_COL)\r\n      )\r\n    ) {\r\n      const newGrid = this.getNewGridWithWalls(this.state.grid, row, col);\r\n      this.setState({\r\n        grid: newGrid,\r\n        isMousePressed: true,\r\n      });\r\n    }\r\n  };\r\n\r\n  handleMouseEnter = (row, col) => {\r\n    if (\r\n      this.state.isMousePressed &&\r\n      !(\r\n        (row === START_NODE_ROW && col === START_NODE_COL) ||\r\n        (row === END_NODE_ROW && col === END_NODE_COL)\r\n      )\r\n    ) {\r\n      const newGrid = this.getNewGridWithWalls(this.state.grid, row, col);\r\n      this.setState({\r\n        grid: newGrid,\r\n      });\r\n    }\r\n  };\r\n\r\n  handleMouseUp = () => {\r\n    this.setState({\r\n      isMousePressed: false,\r\n    });\r\n  };\r\n\r\n  getNewGridWithWalls = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    newGrid[row][col].isWall = !grid[row][col].isWall;\r\n    return newGrid;\r\n  };\r\n\r\n  reset = () => {\r\n    this.setState({\r\n      grid: this.generateGrid(),\r\n    });\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <button onClick={this.visualizeDijkstra} className=\"start-button\">\r\n          Visualize\r\n        </button>\r\n        <button onClick={this.reset} className=\"reset-button\">\r\n          Reset\r\n        </button>\r\n        <div className=\"grid\">\r\n          {this.state.grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx} className=\"row\">\r\n                {row.map((node, nodeIdx) => {\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={node.row}\r\n                      col={node.col}\r\n                      isStart={node.isStart}\r\n                      isFinish={node.isFinish}\r\n                      isVisited={node.isVisited}\r\n                      isWall={node.isWall}\r\n                      isPath={node.isPath}\r\n                      onMouseDown={() =>\r\n                        this.handleMouseDown(node.row, node.col)\r\n                      }\r\n                      onMouseEnter={() =>\r\n                        this.handleMouseEnter(node.row, node.col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                    />\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PathFinderVisualizer;\r\n","import React from 'react';\r\nimport PathFinderVisualizer from './components/PathFinderVisualizer';\r\n\r\nfunction App() {\r\n  return (\r\n    <PathFinderVisualizer />\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}